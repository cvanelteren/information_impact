#distutils : language = c++
import numpy as np
from Models.Models cimport Model
cimport cython
cimport numpy as np

from libcpp.vector cimport vector
from libc.math cimport pi, sqrt, cos, exp

cdef class Schelling(Model):
    def __init__(self,
        object graph, \
        list agentStates = [0, 1, 2],\
        double radius = .8,
        double threshold = .9, \
        int ndir = 8):



        super(Schelling, self).__init__(**locals())

        cdef:
            double[:, ::1] coordinates = np.random.rand(self.nNodes, 2)
        self._coordinates = coordinates *  np.array([1, 2 * pi])

        self._radius         = radius
        self._ndir             = ndir
        self._threshold     = threshold

        self._directions                  = np.linspace(0, 2 * pi, ndir)
    cpdef double[:, ::1] updateState(self, long[::1] nodesToUpdate):
        return self._updateState(nodesToUpdate)

    cdef double _distance(long x, long y):
        """
        Returns distance between polar _coordinates
        """
        cdef:
            double[::1] r1phi1 = self._coordinates[x]
            double[::1] r2phi2 = self._coordinates[y]
        return sqrt(r1phi1[0]** 2 + r2phi2[0]**2  -  2 * r1phi1[0] * r2phi2[0] * cos(r1phi1[1] - r2phi2[1]))


    cdef long[::1] _getNeighbors(self, int node):
        """
        Returns the neighbors within some :self._radius:
        """
        cdef:
            vector[int] neighbors
            int neighbor
            double d
        for neighbor in range(self._nNodes):
            if neighbor != node:
                d = self._distance(neighbor, node)
                if d <= self._threshold:
                    neighbors.push_back(neighbor)
        return neighbors

    cdef long[::1] _move(self, int node, int[::1] neighbors):
        cdef:
            int dir, neighbor, M
            double startPhi
            double endPhi
            vector[double] p = [1] * self._ndir
        M = neighbors.size
        for dir in range(self._ndir - 1):
            startPhi = self._directions[dir]
            endPhi = self._directions[dir + 1]
            for neighbor in range(M):
                neighbor = neighbors[neighbor]
                if startPhi <= self._coordinates[neighbor, 1] < endPhi:
                    p[dir] = p[dir] * exp(-1)
        return p

    cdef double[:, ::1] _updateState(self, long[::1] nodesToUpdate) nogil:
        """
        check
        """
        cdef:
            int N = nodesToUpdate.shape[0]
            int node, neighbor, M
            double percentage
        for node in range(N):
            node        = nodesToUpdate[node]
            neighbors = self._getNeighbors(node)
            percentage = 0
            M = neighbors.size
            for neighbor in range(M):
                neighbor = neighbors[neighbor]
                if  self._states[node] == self._states[neighbor]:
                    percentage += 1 / M
            if percentage <= self._threshold:
                self._coordinates[node] = self._move(node, neighbors)
        return self._coordinates
